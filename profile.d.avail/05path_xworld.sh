#! /bin/false
# Add "xworld"-site binary directories to $PATH.
#
# Version 2023.215
# Copyright (c) 2019-2023 Guenther Brunthaler. All rights reserved.
#
# This script is free software.
# Distribution is permitted under the terms of the GPLv3.

pro_rWB858IAc1YUcQZ9628WWkgWP=$HOME/.cache/profile.vars

{
	test -f "$pro_rWB858IAc1YUcQZ9628WWkgWP" || (

# Create $pro_rWB858IAc1YUcQZ9628WWkgWP.
set -e
cachedir=`dirname -- "$pro_rWB858IAc1YUcQZ9628WWkgWP"`
test -d "$cachedir" \
	|| mkdir -m700 -- "$cachedir"
exec > "$pro_rWB858IAc1YUcQZ9628WWkgWP"

if command -v lsb_release > /dev/null
then
	distro=`lsb_release -is | awk '{print tolower($0)}'`
else
	distro=
fi
if test "$distro" != debian && test -e /etc/debian_version
then
	bdistro=debian
else
	bdistro=
fi

# Workaround for bug: Command substitution does not work in nested
# HERE-DOCUMENTS in dash on armv7l (on x86 it works).
case `id -u` in 0) sbin=sbin;; *) sbin=; esac

awk -f /dev/fd/5 5<< '---------' << =========

# Global temporaries: j, k, n, inv[].
# Global a[]: Current group.
# Global i: a[i] will be next entry within group to be added.
# Global g[]: Previous group.
#
# Both a[] and g[] contain path prefixes already concatenated up to the
# current group depth.

$0 == "" {next} # Ignore lines which became empty after expansion.

$0 == ":" {$0 = ""} # Specify an empty entry which will *not* be igored.

$0 == "<---" {
	# Finish group definition, replace previous group.
	for (i in g) delete g[i]
	for (i in a) {
		g[i] = a[i]; delete a[i]
	}
	i= 0
	next
}

!(0 in g) {
	# No previous group? Just append entry to incomplete current group.
	a[i++] = $0; next
}

{
	# There is a previous group. Append a copy of all entries of the
	# previous group prefixed with the current entry to the new incomplete
	# group.
	for (j = 0; j in g; ++j) a[i++] = $0 g[j]
}

END {
	# Append entries from existing $PATH, but only if they are not
	# duplicates of paths already present in completed group g[].
	for (i = 0; i in g; ++i) inv[g[i]] = i
	n = split(ENVIRON["PATH"], a, ":")
	for (j = 1; j <= n; ++j) {
		if (!(a[j] in inv)) {
			inv[g[i] = a[j]] = i; ++i
		}
	}

	# Assemble new $PATH from paths in g[] which actually do exist in
	# the filesystem.
	$0 = ""; OFS = ":"; k = 1
	ok = system("true")
	for (j = 0; j < i; ++j) {
		if (g[j] == "" || system("test -d \"" g[j] "\"") == ok) {
			#print "PATH[" k "] = " g[j] >> "/dev/stderr"
			$(k++) = g[j]
		}
	}
	print "PATH_rWB858IAc1YUcQZ9628WWkgWP=\"" $0 "\""
}

---------
<---
/tmp
/local
/locally_merged
/internal
${distro:+/}$distro
${bdistro:+/}$bdistro
:
<---
:
/site
/xworld
<---
${sbin:+/}$sbin
/bin
<---
$HOME
$HOME/.local
/usr/local
:
/usr
<---
=========
# $PATH will be assembled from the definitions above by checking a list of
# paths generated from the definitions and appending only those to $PATH which
# actually do exist in the filesystem.
#
# The candidate paths to be checked are generated by concatenating a fixed set
# of path component groups, which are separated by "<--" in the definitions.
# The path components represented by the groups will be concatenated in
# reverse order of their definition.
#
# The last group is special: It will only be used as base directory prefixes,
# but its entries will not be checked for inclusion within $PATH themselves.
#
# Within each group, the possible path components represented by that group
# are defined in separate lines. Empty lines are ignored. The special entry
# ":" means that this group component should be left out of the concatenation
# operation when joining group compoments. In this case, the separating "/"
# will also be omitted.
#
# When checking for possible path combinations to be added to $PATH, the
# combinations will be enumerated in a specific order: The groups will joined
# in reverse order of their definition, and the lines within the groups in the
# same order of their definition.

)
} && {
	. "$pro_rWB858IAc1YUcQZ9628WWkgWP"
	test -n "$PATH_rWB858IAc1YUcQZ9628WWkgWP" \
		&& export PATH=$PATH_rWB858IAc1YUcQZ9628WWkgWP
}
unset pro_rWB858IAc1YUcQZ9628WWkgWP PATH_rWB858IAc1YUcQZ9628WWkgWP
